/* -*- Mode: text ; Coding: euc-japan -*- */
/* Time-stamp: <2010-03-07 23:21:22 cyamauch> */


=============================================================================
                   EGGX / ProCALL  テクニカルドキュメント
=============================================================================


  EGGX の実装についての技術的なメモです．


●ウィンドゥが露出した時の再描画処理をどうするか

  いわゆる Expose イベントでの再描画処理についてです．EGGX の最大のウリの1つ
はライブラリ側での完璧な再描画処理であり，この部分は作り始めた当初からこだわ
り続けてきた部分です．
  再描画処理を行なう方法としては，

    1. BackingStore 属性をつける
    2. タイマー処理などで再描画処理をする
    3. 専用のサーバプログラムを作り，ユーザはサーバに描画命令を送るクライアン
       トプログラムを作る形とし，サーバプログラムが Expose イベントや描画命令
       等をすべて引き受け，処理する．
    4. 子プロセスでイベントを監視して再描画処理をする

がありますが，1. はウィンドゥが少ない場合には良いのですが，ウィンドゥが増える
と効力が無くなり，絵がキープされなくなります．2. はタイマーの間隔をどのくらい
にするかといった問題や，描画領域のサイズが大きくなると X サーバによっては負担
になるといった問題があります．3. は 4 つの中では最もまっとうな方法で，実際に
いくつか実装例がありますが，コンパクトなライブラリを目指す EGGX には向いてい
ないと思われます．4. は X のウィンドゥマネージャ的な発想で，同じウィンドゥに
対して複数のプロセスがアクセスするというもの．X では自然な実装に見えます．
  このように考えて，4. でやる事にしたわけですが，それには次のような工夫が必要
になってくるのでした．

  - 子プロセスの実行ファイルをライブラリに持たせる

    コンパイル・リンク済みの実行ファイルのバイナリ・イメージを libeggx.a に持
  たせ，実行時に /tmp/_xslave_XXXXXX に書き出して実行させています．

  - 親子間の通信に GraphicsExpose イベントを使う

    Version 0.90 までは，X のウィンドゥIDや Pixmap ID などを execv() の引数に
  載せ，子でそれを受けとり，やってくる Expose イベントを XNextEvent() で捉え
  て Pixmap からウィンドゥへのコピー処理を行なっていました．また，レイヤ(すな
  わち Pixmap ID)の切り替えは，割り込みで行なっていました．しかし理想的には，
  EGGX の子プロセスには割り込み等のインタフェースを持たせず，XNextEvent() で
  捉えたイベントを次々と処理させるだけ，という単純な実装にしたいところです．
    この理想を実現するためにちょっと工夫し，Version 0.91 からは XSendEvent()
  関数で GraphicsExpose イベントを互いに送信するようにして，割り込みのインタ
  フェースを無くす事ができました．本来は GraphicsExposeイベントは XCopyArea()
  などで使用されるようですが，EGGX の場合は本来の目的では必要ないものです．こ
  のイベントを扱うための XGraphicsExposeEvent 構造体のメンバを見てみると，都
  合の良い事に major_code，minor_code なんてものが備わっている事に気づき，こ
  れを親子間の通信に使う事にしたわけです．major_code に EGGX のウィンドゥID，
  minor_code に指令コマンド，drawable に値 (PixmapID やキーマスク等) を載せ，
  イベントを送受信しています．Version 0.91 までは，EGGX の 1 ウィンドゥにつき
  1 子プロセスを起動していましたが，Version 0.92 からは，子プロセスに対する指
  令コマンドを強化する事で，画像の保存時以外は常に 1 子プロセスだけで済むよう
  になりました．
    イベントを使って親子通信を行なう時の注意点は，XFlush() のタイミングです．
  これを誤ると，動作が不安定になります．

  - 「見えないウィンドゥ」を使って通信

    もう 1 つの工夫は，親子通信用の GraphicsExpose イベントの送信を「見えない
  ウィンドゥ」を使って行なっている事です．ウィンドゥを開く時は，その時に開い
  たウィンドゥにイベントを送れば良いですが，ウィンドゥをすべて閉じてしまった
  ら送信不能になってしまいます．そういうわけで，EGGX では，ディスプレイと接続
  した直後に通信用の「見えないウィンドゥ」を作っています．


●XGetImage() での注意点

  XSync() を忘れずに．これを忘れると時々中途半端な画像を取得してしまいます．


●同じ関数名で float，double 両用の API とするには

  Version 0.92 から API が float，double 両用になりました．float []，double[]
な引数の場合も，同じ関数の名前をコードに書けるようになっています．
  これは，C99 の tgmath.h に似たマクロ(eggx_tg.h)でやっています．NULL が与え
られた時にどうやって判定するか，ちょっと迷いましたが，sizeof(*(NULL)) が 1 で
ある事を使えば良いようです．


●イベントマスク設定なしでイベントを扱える API とするには

  通常，イベントを扱う前には必ずイベントマスクを設定する必要があります．しか
し，イベントマスクと言われても初心者には「？」ですし，8-bitパソコンの時代にも
そういうものはありませんでした．このようなちょっとした障壁を少しでも無くして
究極の簡単さを実現する事が，EGGX ならではのコダワリです．
  基本的にはこれを実現する方法は簡単で，イベントを扱うAPI(例えばggetevent)に
入ってからイベントマスクを設定し，イベントを待てば良いのです．そして，そのAPI
から抜ける時にイベントマスクを 0 にします．
  しかしこの場合，キー入力やボタン入力では大きな問題はありませんが，マウスの
モーションイベント(Motion，Enter，Leave)では問題があります．というのは，こう
いったモーションイベントはイベントマスク設定後にマウスが必ず動くとは限らない
からです．つまり，イベントマスク設定前にマウスポインタがすごく大きく動いてい
るかもしれないのに，それが検出できないという事です．しかし，ユーザプログラム
側としては，最新のマウスカーソルの位置が得られないと不便です．
  実は，XFree86(Xorg)サーバの場合は，ある程度この事を考慮して作られており，
できるだけ現在のマウスポインタの位置を知らせてくれるようになっています．しか
し，独自実装の商用のXサーバでは，そのようにはなっていない事があり，ユーザが期
待したような動作になるとは限らないのです．
  というわけで，EGGX ではマウスカーソルの位置については，XQueryPointer()で自
前で調べる事にしています(このあたりはウィンドゥマネージャが介入するので，使い
方を知らないとうまくできない)．ついでに，マウスのボタンもステートをチェックし
て，イベントを発行しています．
  さらに，もう1つの問題があります．それはマウスポインタのgrabです．あるウィン
ドゥ上でマウスのドラッグをすると，デフォルトでgrabが働きます．そしてこのgrab
はイベントマスクを設定した「主」にしか解除できない，という事になっているよう
で，かなり難儀したものの1つです．もし「主」がいない場合(つまりイベントマスク
が 0 の場合)には，マウスのボタンが離されるまで，誰も grab を解除できないわけ
です．上で述べたように，EGGX のブロッキングモードでは，イベントマスクのon/off
を繰り返す事になるので，イベントマスクが 0 の時にドラッグが発生すると，もはや
一切イベントが届かなくなってしまうわけです．
  こうなったら，子プロセスに頼るしかありません．ボタンのイベントマスクは常に
on で子プロセスが監視し，ボタンが押されたら即，XUngrabPointer() で grab の解
除をしています．ボタンの Press/Release は例の「見えないウィンドゥ」を使って親
プロセスに転送するという複雑な仕組みになっています．
  一方，ノンブロッキングモードはどうしてるかというと，子プロセスを使わず，親
プロセスだけですべてのイベントを拾っています．この時の注意点は，ボタンのイベ
ントマスクは，1つのプロセスしか on にできないという事です．このあたりは，動作
モードを切り替える時に，親と子とうまく同期をとらないと X のエラーで落ちる事に
なってしまうので注意が必要です．

